Open Pool Protocols


A private, secure, distributed, peer to peer, open source storage framework.

Distributed private storage.

Since each participant offers a multiple of the effective storage received, for the system to work
each participant must feel that they receive storage of a much higher quality, and that other
participants cannot cheat and receive the same higher quality storage without offering a similar
ratio of ordinary storage.  Hence, the service should allow participants to verify easily the
benefits they receive (redundancy, security), and it should be structured such that freeloading is
very difficult.

Message Format
  property              offset   size (bytes)
  protocol version      0x0000   3
  method id             0x0003   1
  length of message     0x0004   2
  reserved              0x0006   2
  parameters            0x0008   variable (= length - 8)

Leaf protocol

The leaf server listens on two ports (numbers?). One port is secured and the other unsecured.

When a the server accepts a connection on either port, it sends a GREETING containing both its id
and a session identifier.  The unsecured port only listens for READ or CHECK requests and supports
handshaking (though it always succeeds and is essentially ignored); it responds to all others with
a <Channel Not Secured> error.  The secured port fully supports handshaking and the entirety of
the api.

Message Constants (Protocol 0.0.1)
  GREETING                  0
  HANDSHAKE REQUEST         1
  HANDSHAKE RESPONSE        2


GREETING <leaf id> <session id>
  Message sent to the client after its connection request was accepted.  If the client connects to
  the secure port and wishes to use the full api, it should respond with a HANDSHAKE REQUEST;
  otherwise it may use the greeting as a signal that the leaf is ready and will handle READ or
  CHECK requests.

HANDSHAKE REQUEST <client id> <block>
  The purpose of the handshake is for each agent to assert its identity to the other, and in
  particular, for the client to prove to the leaf that it has the private key associated with the
  id it presents. Only one handshake request may be made per connection; <client id> is retained
  for use throughout all communications on the connection.
  
  1. Leaf obtains the public key <client key> associated with <client id>.

  2. Leaf decrypts the block with <client key>.

  3. Leaf verifies that the result contains its id, <client id>, <session id>, and a nonce <nonce>
  provided by the client.

  4a. If leaf approves, it creates a data block <response> which contains its id, <client id>, and
  <nonce>.

  4b. If leaf does not approve, it sends HANDSHAKE FAILED and closes the connection.  Leaf or
  client may report this to a monitor.

  5. Leaf encrypts <response> using its private key (<encrypted-response>).

  6. Leaf sends HANDSHAKE RESPONSE <encrypted-response> to client.  Leaf enables its full api.

HANDSHAKE FAILED
  Can be sent either by the client or the leaf.  Indicates that the sender views the recipient as
  untrustworthy.  The connection will immediately be closed by the sender, and the sender may
  report the failure to a monitor.

HANDSHAKE RESPONSE <encrypted-response>
  Sent by the leaf when it approves the handshake.

  1. Client obtains the public key <leaf key> associated with the server.

  2. Client decrypts <encrypted-response> (<response>).

  3. Client verifies that <response> contains the leaf id, its own id, and <nonce>.

  4a. If client approves, it may assume that the full api is available from the leaf.
p
  4b. If client does not approve, it sends HANDSHAKE FAILED and closes the connection.  Client or
  leaf may report this to a monitor.

   
CREATE <block id> <content>
  The client sends a CREATE message to request the leaf to store <content> and to refer to it in
  the future as <client id><block id>.

  The leaf may require the client to prove that it is prosocial before agreeing to store the
  content. Once the content is stored, the leaf sends CREATED <client id> <block id>.  It also
  must notify at least one index of the new content.


Prosocial Challenge

  To ensure that clients requesting storage themselves provide storage to the network, a leaf may
  challenge a client to prove that it retains at least as much data as its request, or the total
  amount of data that it holds, whichever is the lesser.

  1. Challenger requests of an index a list of blocks stored on client.

  2. Challenger selects some subset of those blocks, not to exceed the amount of data client is
  requesting to store.

  3. Challenger requests of an index all of the locations of those blocks in the network.

  4. Challenger selects a <nonce> for each block.  <nonce> may be the same for all blocks, but it
  should not be guessable by client, and should be unique to each challenge.

  5. For each block, and for each host of that block, if the host is not client, then challenger
  sends a CHECK <owner id> <block id> <nonce> to the host, where <owner id> and <block id> refer
  to the block.

  6. For each block, challenger sends a CHECK <owner id> <block id> <nonce> to the client.

  7. Challenger waits until it times out (60 seconds), or until it has receive at least one
  response from each non-client host for each block and until client has responded to all
  requests.

  8. Challenger will consider the challenge successful if
  
    a. Client has responded to all requests.
    b. All client responses for which there is a non-client response must match the non-client
    response.

  9a. If the challenger approves, then it shall continue with the CREATE request.

  9b. If the challenger does not approve, then it shall notify a monitor and send to the client a
  CHALLENGE FAILED message.  The challenger may close the connection.

READ <owner id> <block id>
  returns data block

UPDATE [<owner id>] <block id> <content>
  changes block contents
  requires that requestor has given block stored at this leaf
  requires that requestor is owner or administrator

DELETE [<owner id>] <block id>
  removes block
  requires that requestor is owner or administrator

CHECK <owner id> <block id> <nonce>
  computes the hash of the block with <nonce> as a seed
  refuses other requests to hash the same parameters for a short period (maybe 1 minute)




Distributed File Service
  objective
    Provide distributed anonymous secure storage using spare disk space on internet-connected computers.

  requirements
    All data is encrypted.
    All users are anonymous.

  types of agents
    user
      trades free disk space for redundant backups


User Agent

Parameters
  allocation: amount of disk space to use
  redundancy: number of copies
  allowance: allocation/redundancy



to store a block in the network:
  find a node with free space
  request to store the block
  ensure that user is not requesting to store > allotment

find a node with free space
  some central node has a list of others with free space

free rider problem:
  a malicious user agent fails to store data requested
  a malicious user agent request to store more than allowed






